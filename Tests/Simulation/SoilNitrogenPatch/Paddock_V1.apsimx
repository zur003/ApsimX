{
  "$type": "Models.Core.Simulations, Models",
  "ExplorerWidth": 511,
  "Version": 159,
  "Name": "Simulations",
  "ResourceName": null,
  "Children": [
    {
      "$type": "Models.Storage.DataStore, Models",
      "useFirebird": false,
      "CustomFileName": null,
      "Name": "DataStore",
      "ResourceName": null,
      "Children": [],
      "Enabled": true,
      "ReadOnly": false
    },
    {
      "$type": "Models.Core.Simulation, Models",
      "Descriptors": null,
      "Name": "Base",
      "ResourceName": null,
      "Children": [
        {
          "$type": "Models.Clock, Models",
          "Start": "1972-01-01T00:00:00",
          "End": "1972-12-31T00:00:00",
          "Name": "Clock",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Climate.Weather, Models",
          "ConstantsFile": null,
          "FileName": "%root%\\Tests\\WeatherFiles\\Ruakura.met",
          "ExcelWorkSheetName": "",
          "Name": "Weather",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Summary, Models",
          "Verbosity": 100,
          "Name": "Summary",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Soils.Arbitrator.SoilArbitrator, Models",
          "Name": "Soil Arbitrator",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.ForageDigestibility.Forages, Models",
          "Parameters": [
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "SurfaceOrganicMatter.Residue",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "SurfaceOrganicMatter.Residue",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPRyegrass.Leaf",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPRyegrass.Leaf",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPRyegrass.Stem",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPRyegrass.Stem",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPRyegrass.Stolon",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPRyegrass.Stolon",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPWhiteClover.Leaf",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPWhiteClover.Leaf",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPWhiteClover.Stem",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPWhiteClover.Stem",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPWhiteClover.Stolon",
              "IsLive": true,
              "DigestibilityString": "0.7",
              "FractionConsumable": 1.0,
              "MinimumAmount": 100.0,
              "UseDigestibilityFromModel": false
            },
            {
              "$type": "Models.ForageDigestibility.ForageMaterialParameters, Models",
              "Name": "AGPWhiteClover.Stolon",
              "IsLive": false,
              "DigestibilityString": "0.3",
              "FractionConsumable": 1.0,
              "MinimumAmount": 0.0,
              "UseDigestibilityFromModel": false
            }
          ],
          "Name": "Forages",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.MicroClimate, Models",
          "a_interception": 0.0,
          "b_interception": 0.0,
          "c_interception": 0.0,
          "d_interception": 0.0,
          "SoilHeatFluxFraction": 0.0,
          "MinimumHeightDiffForNewLayer": 0.0,
          "NightInterceptionFraction": 0.0,
          "ReferenceHeight": 2.0,
          "Name": "MicroClimate",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Manager, Models",
          "Code": "using Models.Climate;\nusing System;\nusing System.Linq;\nusing Models.Core;\nusing Models.PMF;\nusing Models.Zones;\nusing Models.AgPasture;\nusing System.Xml.Serialization;\nusing Models.WaterModel;\nusing Models.Surface;\nusing Models.Soils;\nusing APSIM.Shared.Utilities;\nusing System.Collections.Generic;\nusing Models.Interfaces;\nusing Models.Soils.Nutrients;\nusing Models.Soils.NutrientPatching;\nusing MathNet.Numerics.Distributions;\nusing MathNet.Numerics.LinearAlgebra;\nusing System.Diagnostics;\nusing Newtonsoft.Json;\nusing Models.Core.ApsimFile;\n\n\n\n\nnamespace Models\n{\n    [Serializable]\n    [System.Xml.Serialization.XmlInclude(typeof(Model))]\n    public class SimpleCowScript : Model\n    {\n\t\t[Link] Simulation simulation;\n        [Link] Clock clock;\n        [Link] Fertiliser fertiliser;\n        [Link] WaterBalance waterBalance;\n        [Link] SurfaceOrganicMatter surfaceOrganicMatter;\n        [Link] INutrientPatchManager patchManager;\n        [Link] ISummary summary;\n    \n        [Link] private Soil soil;\n        [Link] private Weather weather;\n        [Link] private Zone zone;\n        [Link] private IPhysical soilPhysical;\n        [Link] private List<NutrientPatchManager> patchManagers;\n\n\n\n\n\t\t/// <summary>class for encapsulating a urine return.</summary>\n\t\tpublic class DoUrineReturnEventData : EventArgs\n\t\t{\n    \t\t/// <summary>Amount of urine to return (kg)</summary>\n\t    \tpublic double Amount { get; set;  }\n\n\t   \t\t/// <summary>Depth (mm) of soil to return urine into.</summary>\n    \t\tpublic double Depth { get; set;  }\n\n\t   \t\t/// <summary>Grazed dry matter.</summary>\n\t\t    public double GrazedDM { get; set; }\n\t\t}\n\n\t\t/// below is the definition of the event\n\t\tpublic event EventHandler<DoUrineReturnEventData> DoCowUrineReturn;\n\n\n        // --------------- Privates ---------------------------------\n\n        //private double CowBodyWeight = 450.0;      // kg put on UI\n        //private string CowDateCalving = \"1-aug\";   // put on UI\n        //private string CowDateInCalf = \"1-nov\";    //  3 months after calving\n        //private string CowDateDryOff = \"30-apr\";   // put on UI\n        private double CowMSPerDay = 0.0;         // kgMS/day/head - calculated, initialising here\n        private double CowMSEnergyPerKg = 77.0;         // MJME/kg MS (trying 77 c.f. 80)\n        private double CowWalkingDist = 3.0;            // km\n        private double CowWalkingEnergyPerKm = 2.0;         // MJME/km\n        private double[] CowN2BodyPerc = { 30.0, 10.0 };         // Percent N in intake to body and product for milking and dry\n        private double[] CowN2UrinePerc = { 42.0, 54.0 };         // Percent N in intake to uriney and product for milking and dry\n        private double[] CowN2DungPerc = { 28.0, 36.0 };         // Percent N in intake to dung and product for milking and dry\n        //private double[] LactationCurveParam = { 20.0, 0.2, -0.04, 0.092 };         // put on UI Parameters for the lactation curve, last parm 0.113 will give 500 kg MS, 0.092 will give 406 kg MS\n        private double WeeksBeforeCalving = 0.0;     // cannot this be calculated?\n        private double LactationWeek = 0.0;          // and this?\n        private double UrineDepth = 0;               // wot?\n                \n\t\t// perhaps should relate this to cow body weight\n        //private double[] CowPregnancyParam = {54.59, -0.135}; // multiplier and exponential parameters for pregnancy energy (25 kg calf), time in weeks before\n        //private double[] CowPregnancyParam = {63.931, -0.139}; // multiplier and exponential parameters for pregnancy energy (30 kg calf), time in weeks before\n        private double[] CowPregnancyParam = { 72.154, -0.143 }; // multiplier and exponential parameters for pregnancy energy (35 kg calf), time in weeks before\n        //private double[] CowPregnancyParam = {76.208, -0.142}; // multiplier and exponential parameters for pregnancy energy (40 kg calf), time in weeks before\n   \n        private double CowMaintME = 54; //But will be overridden in StartSimulation  \n        // MJME/day https://www.dairynz.co.nz/media/5789573/facts_and_figures_web_chapter4_cow_feed_requirements.pdf page 4 and Excel regression on table \"Maintenance MJ ME/day\"\n\n        private double AmountDungCReturned = 0.0;\n        private double myResidual;\n        bool GrazeNow = false;\n\n\n        // --------------- Parameters --------------------------------------\n\n        [Description(\"Verbose output?\")] public bool Verbose { get; set; } \n\n        [Separator(\"Cow characteristics\")]\n        \n        [Description(\"Cow mature live weight (kg) - only use 450 until make some of the other parameters dynamic\")]\n        [Units(\"kg\")]\n        public double CowBodyWeight { get; set; } // = 450.0;\n       \n        [Description(\"Calving date (dd-mmm)\")]\n        [Units(\"dd-mmm\")]\n        public string CowDateCalving{ get; set; }\n       \n        [Description(\"If-calf date (dd-mmm)\")]\n        [Units(\"dd-mmm\")]\n        public string CowDateInCalf{ get; set; }\n       \n        [Description(\"Dry-off date (dd-mmm)\")]\n        [Units(\"dd-mmm\")]\n        public string CowDateDryOff{ get; set; }\n\n        [Separator(\"          Woods equation lactation curve - 20.0, 0.2, -0.04, 0.092 for 406 kg MS in the seasoon. Last param at 0.113 will give 500\")]\n\n        [Description(\"Lactation curve parameters - try 20.0, 0.2, -0.04, 0.092 for 406 kg MS in the seasoon \")]\n        [Units(\"various\")]\n        public double[] LactationCurveParam { get; set; }\n       \n        /*[Description(\"\")]\n        [Units(\"\")]\n        public double X { get; set; }\n       \n        [Description(\"\")]\n        [Units(\"\")]\n        public double X { get; set; }\n       \n        [Description(\"\")]\n        [Units(\"\")]\n        public double X { get; set; }\n       \n        [Description(\"\")]\n        [Units(\"\")]\n        public double X { get; set; }*/\n       \n        \n\n        [Separator(\"Herd and ME demand information\")]\n\n\n        [Description(\"Stocking rate (cows/ha)\")]\n        [Units(\"cows/ha\")]\n        public double StockingRate { get; set; }\n\n        [Description(\"Number of paddocks on the farm\")]\n        [Units(\"days\")]\n        public int Num1HaPaddocks { get; set; }\n\n        [Description(\"N concentration of the silage fed out (% N in DM)\")]\n        [Units(\"kgN/kgDM\")]\n        public double SilageNConc { get; set; }\n\n        [Description(\"ME concentration of the silage fed out (MJ ME / kg DM)\")]\n        [Units(\"MJME/kgDM\")]\n        public double SilageMEConc { get; set; }\n\n        [Separator(\"Excreta return parameters\")]\n\n        [Description(\"Number of urinations per animal per day\")]\n        public double UrinationsPerHead { get; set; }\n\n\n        [Description(\"Size of the edge effect (m)\")]\n        [Units(\"m\")]\n        public double patchMargin { get; set; }\n        \n        [Description(\"Adjust the urine volume and depth with N load scaling?\")]\n        public bool AdjustVolme { get; set; }\n\n\n        [Separator(\"Patch characteristics\")]\n\n   \n        // --------------------------- Outputs -------------------------------------------\n      \n\n        [Units(\"m2\")]\n        public double AreaUrinePatchesToday { get; set; }\n\n        [Units(\"kgN/ha\")]\n        public double AmountUrineNReturned { get; set; }\n\n        [Units(\"head/ha\")]\n        public double StockingDensity { get; set; }\n\n        public double LoadAdjustmentPropOverall { get; set; }\n\n        public double LoadAdjustmentGrammesIndividual { get; set; }\n\n        [Units(\"mm\")]\n        public double AverageUrineDepth { get; set; }\n   \n        [Units(\"kgN/ha\")]\n        public double UrineNReturned { get; set; }\n\n        public double SilageMade { get; set; }\n        public double SilageFed { get; set; }\n        public double SilageNFed { get; set; }\n        public double SilageMEFed { get; set; }\n        public double HerdMEDemand { get; set; }\n        public double CowMEDemand { get; set; }\n        public double CowDMIntake { get; set; }\n        public string CowState { get; set; }\n\n\n        // --------------------------- Methods -------------------------------------------\n    \n        /// <summary>Invoked when simulation starts.</summary>\n        /// <param name=\"sender\">The sender of the event.</param>\n        /// <param name=\"e\">The event arguments.</param>\n        [EventSubscribe(\"StartOfSimulation\")]\n        private void OnStartOfSimulation(object sender, EventArgs e)\n        {\n        \t//Debugger.Break();\n        \t\n\t\t\tCowMaintME = CowBodyWeight * 0.0942 + 11.507;   \n        \t// MJME/day https://www.dairynz.co.nz/media/5789573/facts_and_figures_web_chapter4_cow_feed_requirements.pdf page 4 and Excel regression on table \"Maintenance MJ ME/day\"\n\n        }\n\n        \n        /// <summary>Invoked by clock to do management actions.</summary>\n        /// <param name=\"sender\">The sender of the event.</param>\n        /// <param name=\"e\">The event arguments.</param>\n        [EventSubscribe(\"DoManagement\")]\n        private void OnDoManagement(object sender, EventArgs e)\n        {\n            CowPhysiologicalState();\n\n            SilageMade = 0.0;\n            SilageFed = 0.0;\n            SilageNFed = 0.0;\n            SilageMEFed = 0.0;\n      \n            UrineNReturned = 0.0;\n            \n            //TODO these grazing parameters need to go back into the manager!\n            StockingDensity = /*DaysPerGrazeArray[Clock.month - 1] * */ Num1HaPaddocks * StockingRate;\n\n\n\n        }\n        \n        \n        /// <summary>Invoked when a graze occurs.</summary>\n        /// <param name=\"sender\">The sender of the event.</param>\n        /// <param name=\"e\">The event arguments.</param>\n        [EventSubscribe(\"DoUrineReturn\")]\n        private void OnDoUrineReturn(object sender, SimpleGrazing.UrineReturnType urineReturn)\n        {\n        \n\t\t\tDoCowUrineReturn.Invoke(this,\n\t            new DoUrineReturnEventData()\n    \t        {\n    \t        \tAmount = 24, //AmountUrineNReturned,\n    \t            Depth = 200, //DepthUrineIsAdded,\n    \t            GrazedDM = 1200 //GrazedDM\n    \t        });\n        \n        }\n\n        \n        \n        private void CowPhysiologicalState()\n        {\n            if (DateUtilities.CompareDates(CowDateCalving, clock.Today) > 0)\n                WeeksBeforeCalving = (DateUtilities.GetDate(CowDateCalving, (clock.Today.Year + 1)) - clock.Today).TotalDays / 7.0;\n            else\n                WeeksBeforeCalving = (DateUtilities.GetDate(CowDateCalving, clock.Today.Year) - clock.Today).TotalDays / 7.0;\n\n\n            if (DateUtilities.CompareDates(CowDateCalving, clock.Today) <= 0)\n                LactationWeek = (clock.Today - DateUtilities.GetDate(CowDateCalving, (clock.Today.Year - 1))).TotalDays / 7.0;\n            else\n                LactationWeek = (clock.Today - DateUtilities.GetDate(CowDateCalving, (clock.Today.Year))).TotalDays / 7.0;\n\n\n            // find state\n            if (DateUtilities.WithinDates(CowDateCalving, clock.Today, CowDateInCalf))\n            {\n                CowState = \"Milking-Notpreg\";\n                CowMSPerDay = LactationCurveParam[0] * Math.Pow(LactationWeek, LactationCurveParam[1]) * Math.Exp(LactationCurveParam[2] * LactationWeek) * LactationCurveParam[3];\n                //CowMEDemand = 0.0 + 0.0 + CowWalkingDist * CowWalkingEnergyPerKm + CowMSPerDay * CowMSEnergyPerKg;\n                CowMEDemand = CowMaintME + 0.0 + CowWalkingDist * CowWalkingEnergyPerKm + CowMSPerDay * CowMSEnergyPerKg;\n            }\n            else if (DateUtilities.WithinDates(CowDateInCalf, clock.Today, CowDateDryOff))\n            {\n                CowState = \"Milking-Pregnant\";\n                CowMSPerDay = LactationCurveParam[0] * Math.Pow(LactationWeek, LactationCurveParam[1]) * Math.Exp(LactationCurveParam[2] * LactationWeek) * LactationCurveParam[3];\n                //CowMEDemand = 0.0 + (CowPregnancyParam[0] * Math.Exp(CowPregnancyParam[1] * WeeksBeforeCalving)) + CowWalkingDist * CowWalkingEnergyPerKm + CowMSPerDay * CowMSEnergyPerKg;  //=72.154*EXP(-0.143*L3)\n                CowMEDemand = CowMaintME + (CowPregnancyParam[0] * Math.Exp(CowPregnancyParam[1] * WeeksBeforeCalving)) + CowWalkingDist * CowWalkingEnergyPerKm + CowMSPerDay * CowMSEnergyPerKg;  //=72.154*EXP(-0.143*L3)\n            }\n            else if (DateUtilities.WithinDates(CowDateDryOff, clock.Today, CowDateCalving))\n            {\n                CowState = \"Dry-Pregnant\";\n                CowMSPerDay = 0.0;\n                CowMEDemand = CowMaintME + (CowPregnancyParam[0] * Math.Exp(CowPregnancyParam[1] * WeeksBeforeCalving)) + CowWalkingDist * CowWalkingEnergyPerKm + 0.0;  //=72.154*EXP(-0.143*L3)\n            }\n            else\n                throw new Exception(\"Error in calculating CowState\");  \n\n            HerdMEDemand = CowMEDemand * StockingDensity;\n            //summary.WriteMessage(this, Clock.Today + \" CowState \" + CowState + \" CowMSPerDay \" + CowMSPerDay + \" CowMEDemand \" + CowMEDemand, MessageType.Diagnostic);\n\n      \n        }\n        \n        \n    }\n}\n",
          "Parameters": [
            {
              "Key": "Verbose",
              "Value": "False"
            },
            {
              "Key": "CowBodyWeight",
              "Value": "450"
            },
            {
              "Key": "CowDateCalving",
              "Value": "1-aug"
            },
            {
              "Key": "CowDateInCalf",
              "Value": "1-nov"
            },
            {
              "Key": "CowDateDryOff",
              "Value": "10-may"
            },
            {
              "Key": "LactationCurveParam",
              "Value": "20, 0.2, -0.04, 0.092"
            },
            {
              "Key": "StockingRate",
              "Value": "2.25"
            },
            {
              "Key": "Num1HaPaddocks",
              "Value": "25"
            },
            {
              "Key": "SilageNConc",
              "Value": "2.75"
            },
            {
              "Key": "SilageMEConc",
              "Value": "11"
            },
            {
              "Key": "UrinationsPerHead",
              "Value": "11"
            },
            {
              "Key": "patchMargin",
              "Value": "0.1"
            },
            {
              "Key": "AdjustVolme",
              "Value": "False"
            }
          ],
          "Name": "SimpleCow",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Manager, Models",
          "Code": "using Newtonsoft.Json;\nusing Models.Soils.Nutrients;\nusing Models.Soils.NutrientPatching;\nusing Models.Interfaces;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing APSIM.Shared.Utilities;\nusing Models.Surface;\nusing Models.Soils;\nusing System.Xml.Serialization;\nusing Models.AgPasture;\nusing Models.Zones;\nusing Models.PMF;\nusing Models.Core;\nusing Models.Core.ApsimFile;\nusing System;\nusing System.Linq;\nusing Models.Climate;\n\nnamespace Models\n{\n    [Serializable]\n    [System.Xml.Serialization.XmlInclude(typeof(Model))]\n    public class Script : Model\n    {\n        [Link] private Clock clock;\n        [Link] private Soil soil;\n        [Link] private ISummary summary;\n        [Link] private Weather weather;\n        [Link] private Zone zone;\n        [Link] private IPhysical soilPhysical;\n        [Link] private List<NutrientPatchManager> patchManagers;\n\n        private Sward sward;\n      \n        [Description(\"Verbose reporting to the summary file?\")]\n        public bool Verbose { get; set; }\n        \n        [Description(\"Should this simulation create Patches? If not then explict Zones will be created\")]\n        public bool PseudoPatches { get; set; }\n        \n        [Description(\"How many patches or zones should be created?\")]\n        public int ZoneCount { get; set; }\n        \n        [Description(\"Nature of nutrient return\")]\n        public UrineReturnTypes UrineReturnType { get; set; }\n\n        [Description(\"Pattern (spatial) of nutrient return\")]\n        public UrineReturnPatterns UrineReturnPattern { get; set; }\n\n        [Description(\"Depth of urine penetration (mm)\")]\n        public double UrineDepthPenetration { get; set; }\n\n        public int ZoneNumForUrine { get; set; }    // zone or patch that urine will be applied to\n        public int NumZonesForUrine { get; set; }   // not enabled yet but for applying urine across more than one zone or patch\n        public double DivisorForReporting { get; set; }   // \n        \n        public double HarvestedWt { get; set; }     // from the whole paddock\n        public double HarvestedN { get; set; }      // from the whole paddock\n        public double AmountUrineNReturned { get; set; }   // to the whole paddock\n        public double AmountDungNReturned { get; set; }    // to the whole paddock\n        public double AmountDungCReturned { get; set; }    // to the whole paddock\n        \n        private double[] MonthlyUrineNAmt;                 // breaks the N balance but useful for testing\n        private bool GrazeToday;\n\t\tprivate double[] UrineDepthPenetrationArray;\n\n\t\t[NonSerialized]\n\t\tRandom pseudoRandom; // = new Random(666);  // sets a constant seed value\n\n\n        public enum UrineReturnPatterns\n        {\n            // <summary>Not enabled Uniform</summary>\n            //UniformAcrossAllPatches,\n            /// <summary>Rotating in order</summary>\n            RotatingInOrder,\n            /// <summary>Not enabled Random</summary>\n            Random,\n            /// <summary>Not enabled Pseudo-random</summary>\n            PseudoRandom\n        }\n        \n        public enum UrineReturnTypes\n        {\n            /// <summary>FromHarvest</summary>\n            FromHarvest,\n            /// <summary>SetMonthly</summary>\n            SetMonthly,\n            /// <summary>From SimpleCow</summary>\n            FromElsewhere\n        }\n\n\n        public override void OnPreLink()\n        {\n            var simulation = Parent.Parent as Simulation;\n            var zone = simulation.FindChild<Zone>();\n                \n\t\t\t// Set the maximum N uptake for all species\n\t\t\tforeach (var species in zone.FindAllDescendants<PastureSpecies>())\n\t\t\t{\n\t\t\t\tvar root = species.FindChild<PastureBelowGroundOrgan>();\n\t\t\t\troot.MaximumNUptake = 3.0;\n\t\t\t}\n\t\t\t\t\n            if (!PseudoPatches)\n            {\n\t            zone.Area = 1.0 / ZoneCount;  // and then this will apply to all the new zones  \n\t            for (int i = 0; i < ZoneCount-1; i++)\n\t            {\n\t                var newZone = Apsim.Clone(zone);\n\t                Structure.Add(newZone, simulation);\n\t            }\n\t         }\n        }\n\n        [EventSubscribe(\"StartOfSimulation\")] private void OnStartOfSimulation(object sender, EventArgs e)\n        {\n            if (Verbose && !PseudoPatches)\n            \tsummary.WriteMessage(this, \"Created \" + ZoneCount + \" identical zones, each of area \" + (1.0 / ZoneCount) + \" ha\", MessageType.Diagnostic);\n\n            if (Verbose)\n            \tsummary.WriteMessage(this, \"Initialising the ZoneManager for grazing, urine return and reporting\", MessageType.Diagnostic);\n\n            sward = new Sward(zone); \n\t\t\tpseudoRandom = new Random(666);  // sets a constant seed value\n\t\t\t\n\t\t\tif (PseudoPatches)\n\t\t\t\tDivisorForReporting = 1.0;\n\t\t\telse\n\t\t\t\tDivisorForReporting = ZoneCount;\n\t\t\t\n\t\t\tGrazeToday = false;\n\n            MonthlyUrineNAmt = new double[] { 24, 19, 17, 12, 8, 5, 5, 10, 16, 19, 23, 25 }; //This is to get a pattern of return that varies with month but removes the variation that might be caused by small changes in herbage growth\n            //MonthlyUrineNAmt = new double[] { 100, 100, 100, 12, 8, 5, 5, 10, 16, 19, 23, 25 }; //This is to get a pattern of return that varies with month but removes the variation that might be caused by small changes in herbage growth\n\n            if (PseudoPatches)\n            {\n                foreach (var patchManager in patchManagers)\n                {\n                    //patchManager.MaximumNitrogenAvailableToPlants = 0.45; This is now set in pre start\n                    patchManager.NPartitionApproach = PartitionApproachEnum.BasedOnConcentrationAndDelta;\n                    patchManager.AutoAmalgamationApproach = AutoAmalgamationApproachEnum.None;\n                    patchManager.basePatchApproach = BaseApproachEnum.IDBased;\n                    patchManager.AllowPatchAmalgamationByAge = false;\n                    patchManager.PatchAgeForForcedMerge = 1000000.0;  // ie don't merge                                \n                }\n\n                int[] PatchToAddTo = new int[1];  //need an array variable for this\n                string[] PatchNmToAddTo = new string[1];  \n                int nPatchesAdded = 0;\n                double NewArea = 1.0 / ZoneCount;\n\t\t\t\t\n                while (nPatchesAdded < ZoneCount - 1)\n                {\n                    AddSoilCNPatchType NewPatch = new AddSoilCNPatchType();\n                    NewPatch.DepositionType = DepositionTypeEnum.ToNewPatch;\n                    NewPatch.AreaFraction = NewArea;\n                    PatchToAddTo[0] = 0;\n                    PatchNmToAddTo[0] = \"0\";\n                    NewPatch.AffectedPatches_id = PatchToAddTo;\n                    NewPatch.AffectedPatches_nm = PatchNmToAddTo;\n                    NewPatch.SuppressMessages = Verbose;\n\n                    foreach (var patchManager in patchManagers)\n                        patchManager.Add(NewPatch);\n                    nPatchesAdded += 1;\n                }                \n\n                if (Verbose)\n                \tsummary.WriteMessage(this, patchManagers[0].NumPatches.ToString() + \" pseudopatches have been created\", MessageType.Diagnostic); \n            }\n\n            if (Verbose)\n            \tsummary.WriteMessage(this, \"Finished initialising the Manager for grazing, urine return and reporting\", MessageType.Diagnostic);\n\n            NumZonesForUrine = 1;  // in the future this might be > 1\n            ZoneNumForUrine = -1;  // this will be incremented to 0 (first zone) below \n        }\n\n        [EventSubscribe(\"DoManagement\")]\n        private void OnDoManagement(object sender, EventArgs e)\n        {    \n\n            // if this is the start of the simulation then sort out the depth for the urine penetration. Can't do this in initialisation because of the module order\n            if (clock.Today == clock.StartDate)\n                UrinePenetration();\n\n            GrazeToday = false;\n\t\t\tif (clock.Today.AddDays(1).Day == 1)    // why separate this from the if below?  - to allow for multiple options in the future\n                GrazeToday = true;\n\n            if (GrazeToday)\n            {\n                if (Verbose)\n                \tsummary.WriteMessage(this, \"Doing grazing\", MessageType.Diagnostic);\n\n                // do the herbage removal part of the grazing\n                int i = -1;  // to use as a zone counter\n                HarvestedWt = 0.0;\n                HarvestedN = 0.0;\n                foreach (Zone zone in this.Parent.FindAllInScope<Zone>())   // NOTE - this is a zone regardless of pseudopatches \n                {\n                    i += 1;\n                    var sward = new Sward(zone);\n                    sward.Graze(amount: 1000.0, type: \"SetResidueAmount\", Verbose);   // note that I have hardcoded the grazing residual for now\n                    HarvestedWt += sward.HarvestedWt * zone.Area;\n                    HarvestedN += sward.HarvestedN * zone.Area;\n                    if (Verbose)\n                    \tsummary.WriteMessage(this, \"Just harvested \" + HarvestedWt + \" from Zone \" + zone, MessageType.Diagnostic);\n                }\n\n                if (UrineReturnType == UrineReturnTypes.FromHarvest)\n                {\n                    AmountUrineNReturned = HarvestedN * 0.50;  // \n                    AmountDungNReturned = HarvestedN * 0.35;  // \n                    AmountDungCReturned = AmountDungNReturned * 20;\n                }\n                else if (UrineReturnType == UrineReturnTypes.SetMonthly)\n                {\n                \tAmountUrineNReturned = MonthlyUrineNAmt[clock.Today.Month - 1];   //  hardcoded as an input\n                \tAmountDungNReturned = AmountUrineNReturned * (0.35 / 0.50);  // \n                \tAmountDungCReturned = AmountDungNReturned * 20;\n                }\n                if (Verbose)\n                \tsummary.WriteMessage(this, \"The amount of urine N to be returned to the whole paddock is \" + AmountUrineNReturned, MessageType.Diagnostic);\n\n                DoUrineReturn();\n\n                DoTramplingAndDungReturn();\n\n                if (Verbose)\n                \tsummary.WriteMessage(this, \"Finished Grazing\", MessageType.Diagnostic);\n\n            }\n        }\n        \n        [EventSubscribe(\"DoCowUrineReturn\")]\n        private void OnDoCowUrineReturn(object sender, SimpleCowScript.DoUrineReturnEventData myEventData)\n        {    \n        \t\tvar junk = myEventData.Amount;\n\t\t}        \n        \n        \n\n        public void DoTramplingAndDungReturn()\n        {\n \t\t\t// Note that dung is assumed to be spread uniformly over the paddock (patches or sones).\n \t\t\t// There is no need to bring zone area into the calculations here but zone area must be included for variables reported FROM the zone to the upper level\n \t\t\t           \n            int i = -1;  // patch or paddock counter\n            foreach (Zone zone in this.Parent.FindAllInScope<Zone>())\n            {\n                i += 1;\n                SurfaceOrganicMatter surfaceOM = zone.FindInScope<SurfaceOrganicMatter>() as SurfaceOrganicMatter; \n\n                // do some trampling of litter\n                // accelerate the movement of surface litter into the soil - do this before the dung is added\n                double temp = surfaceOM.Wt * 0.1;\n\n                TillageType trampling = new TillageType();\n                surfaceOM.Incorporate(fraction: (double) 0.1, depth: (double)100.0, Verbose);\n\n                if (Verbose)\n                \tsummary.WriteMessage(this, \"For patch \" + i + \" the amount of litter trampled was \" + temp + \" and the remaining litter is \" + (surfaceOM.Wt), MessageType.Diagnostic);\n\n                // move the dung to litter  \n                AddFaecesType dung = new AddFaecesType();\n                dung.OMWeight = AmountDungCReturned / 0.4;  //assume dung C is 40% of OM  \n                dung.OMN = AmountDungNReturned;\n                surfaceOM.AddFaeces(dung);\n                if (Verbose)\n                \tsummary.WriteMessage(this, \"For patch \" + i + \" the amount of dung DM added to the litter was \" + (AmountDungCReturned / 0.4) + \" and the amount of N added in the dung was \" + (AmountDungNReturned), MessageType.Diagnostic);\n\n            } \n        }\n\n        public void DoUrineReturn()\n        {\n            GetZoneForUrineReturn();  \n\n      \t\tif (Verbose)\n      \t\t\tsummary.WriteMessage(this, \"The Zone for urine return is \" + ZoneNumForUrine, MessageType.Diagnostic);\n\n            if (!PseudoPatches)\n            {\n            \tint i = -1; //to count the zones\n\t            foreach (Zone zone in this.Parent.FindAllInScope<Zone>())\n    \t        {\n    \t            i += 1;\n    \t            if (i == ZoneNumForUrine)\n    \t            {\n    \t                Fertiliser thisFert = zone.FindInScope<Fertiliser>() as Fertiliser;\n\n  \t                    thisFert.Apply(amount: AmountUrineNReturned / zone.Area, \n  \t                    \t\ttype: Fertiliser.Types.UreaN, \n  \t                    \t\tdepthTop: 0.0, \n  \t                    \t\tdepthBottom: UrineDepthPenetration, \n  \t                    \t\tdoOutput: Verbose);\n                                        \n    \t         \t\tif (Verbose)\n    \t         \t\t\tsummary.WriteMessage(this, AmountUrineNReturned + \" urine N added to Zone \" + i + \", the local load was \" + AmountUrineNReturned / zone.Area + \" kg N /ha\", MessageType.Diagnostic);\n    \t             }\n             \t}\n        \t}\n        \telse // PseudoPatches\n        \t{\n\t\t                int[] PatchToAddTo = new int[1];  //because need an array variable for this\n        \t\t        string[] PatchNmToAddTo = new string[0];  //need an array variable for this\n        \t\t        //List<IModel> zones = this.FindAllInScope<Zone>().OfType<IModel>().ToList();   //TODO ask Dean - is all this needed?\n        \t\t        double[] UreaToAdd = new double[soilPhysical.Thickness.Length];  \n\n        \t\t        for (int ii = 0; ii <= (soilPhysical.Thickness.Length - 1); ii++)\n        \t\t            UreaToAdd[ii] = UrineDepthPenetrationArray[ii]  * AmountUrineNReturned * ZoneCount;\n\n        \t\t        // needed??   UreaReturned += AmountFertNReturned;\n\n        \t\t        AddSoilCNPatchType CurrentPatch = new AddSoilCNPatchType();\n        \t\t        CurrentPatch.Sender = \"manager\";\n        \t\t        CurrentPatch.DepositionType = DepositionTypeEnum.ToSpecificPatch;\n        \t\t        PatchToAddTo[0] = ZoneNumForUrine;\n        \t\t        CurrentPatch.AffectedPatches_id = PatchToAddTo;\n        \t\t        CurrentPatch.AffectedPatches_nm = PatchNmToAddTo;\n        \t\t        CurrentPatch.Urea = UreaToAdd;\n\n        \t\t        var patchManager = soil.FindChild<NutrientPatchManager>(); \n\n    \t         \t\tif (Verbose)\n\t        \t\t        summary.WriteMessage(this, \"Patch MinN prior to urine return: \" + patchManager.MineralNEachPatch[ZoneNumForUrine], MessageType.Diagnostic);\n        \t\t        patchManager.Add(CurrentPatch); \n    \t         \t\tif (Verbose)\n\t        \t\t        summary.WriteMessage(this, \"Patch MinN after urine return: \" + patchManager.MineralNEachPatch[ZoneNumForUrine], MessageType.Diagnostic);\n        \t} \n        }\n\n        public void GetZoneForUrineReturn()\n        {\n            if (UrineReturnPattern == UrineReturnPatterns.RotatingInOrder) \n            {\n\t            ZoneNumForUrine += 1;  //increment the zone number - it was initialised at -1. NOTE, ZoneNumForUrine is used for both zones and patches\n\t            if (ZoneNumForUrine >= ZoneCount)\n\t                ZoneNumForUrine = 0;  // but reset back to the first patch if needed\n            }\n            else if (UrineReturnPattern == UrineReturnPatterns.Random)\n            {\n\t            Random rnd = new Random();\n\t            ZoneNumForUrine = rnd.Next(0, ZoneCount); // in C# the maximum value (ZoneCount) will not be selected\n            }\n            else if (UrineReturnPattern == UrineReturnPatterns.PseudoRandom)\n            {\n\t            ZoneNumForUrine = pseudoRandom.Next(0, ZoneCount); // in C# the maximum value (ZoneCount) will not be selected\n            }\n\t\t\telse\n\t\t\t\tthrow new Exception(\"UrineResturnPattern not recognised\");\n\n\t\t\tif (Verbose)\n            \tsummary.WriteMessage(this, \"The next zone/patch for urine return is \" + ZoneNumForUrine, MessageType.Diagnostic);\n        }\n\n\n        public void UrinePenetration()\n        {\n            // note that this only looks at the first paddock and assumes that all the paddocks are the same\n            int iii = -1;  // to use as a patch counter\n            foreach (Zone zone in this.Parent.FindAllInScope<Zone>().OfType<IModel>().ToList())\n            {\n                iii += 1;\n                if (iii == 0)\n                {\n                    Soil soil = zone.FindInScope<Soil>() as Soil;\n                    double tempDepth = 0.0;\n                    UrineDepthPenetrationArray = new double[soilPhysical.Thickness.Length];\n                    for (int i = 0; i <= (soilPhysical.Thickness.Length - 1); i++)\n                    {\n                        tempDepth += soilPhysical.Thickness[i];\n                        if (tempDepth <= UrineDepthPenetration)\n                        {\n                            UrineDepthPenetrationArray[i] = soilPhysical.Thickness[i] / UrineDepthPenetration;\n                        }\n                        else\n                        {\n                            UrineDepthPenetrationArray[i] = (UrineDepthPenetration - (tempDepth - soilPhysical.Thickness[i])) / (tempDepth - (tempDepth - soilPhysical.Thickness[i])) * soilPhysical.Thickness[i] / UrineDepthPenetration;\n                            UrineDepthPenetrationArray[i] = Math.Max(0.0, Math.Min(1.0, UrineDepthPenetrationArray[i]));\n                        }\n                        if (Verbose)\n                        \tsummary.WriteMessage(this, \"The proportion of urine applied to the \" + i + \"th layer will be \" + UrineDepthPenetrationArray[i], MessageType.Diagnostic);\n                    }\n                }\n            }\n\n        } \n\n\n        \n   \n    // A class for aggregating a pasture species mix.  ??????????????? is this needed now?\n    [Serializable]\n    class Sward\n    {\n     \tprivate const double Epsilon = 0.000000001;\n        private double amountRequired;\n\n        public Sward(Zone zone)\n        {\n            Species = zone.FindAllDescendants<PastureSpecies>().OfType<IModel>().ToList().Cast<PastureSpecies>().ToList();\n\t\t}\n\t\t\n        public List<PastureSpecies> Species { get; private set; }\n\n        public double HarvestableWt { get { return Species.Sum(sp => sp.Harvestable.Wt); } }\n\n        public double HarvestedWt { get { return Species.Sum(sp => sp.HarvestedWt); } }\n\n        public double HarvestedN { get { return Species.Sum(sp => sp.HarvestedN); } }\n\n        public double StandingHerbageWt { get { return Species.Sum(sp => sp.Standing.Wt); } }\n\n        public double AboveGroundWt { get { return Species.Sum(sp => sp.AboveGroundWt); } }\n\n        public bool IsAlive\n        {\n            get\n            {\n                bool alive = true;\n                Species.ForEach(sp => alive = alive && sp.PlantStatus == \"alive\");\n                return alive;\n            }\n         }\n     \n\n        /// <summary>Removes plant material simulating a graze event.</summary>\n        /// <param name=\"amount\">The DM amount (kg/ha)</param>\n        /// <param name=\"type\">How the amount is interpreted (SetResidueAmount or SetRemoveAmount)</param>\n        public void Graze(double amount, string type, bool Verbose)\n        {\n            double amountAvailable = HarvestableWt;\n            if (IsAlive || (amountAvailable > Epsilon))\n            {\n                // Get the amount required to remove\n                if (type.ToLower() == \"setresidueamount\")\n                {\n                    // Remove all DM above given residual amount\n                    amountRequired = Math.Max(0.0, AboveGroundWt - amount);\n                }\n                else if (type.ToLower() == \"setremoveamount\")\n                {\n                    // Remove a given amount\n                    amountRequired = Math.Max(0.0, amount);\n                }\n                else\n                {\n                    throw new Exception(\"Type of amount to remove on graze not recognized (use \\'SetResidueAmount\\' or \\'SetRemoveAmount\\'\");\n                }\n                // Get the actual amount to remove\n                double amountToRemove = Math.Max(0.0, Math.Min(amountRequired, amountAvailable));\n\n                // Get the amounts to remove by mySpecies:\n                if (amountToRemove > Epsilon)\n                {\n                    double[] fractionToRemove = new double[Species.Count];\n                    for (int s = 0; s < Species.Count; s++)\n                    {\n                        // get the fraction to required for each mySpecies, partition according to available DM to harvest\n                        fractionToRemove[s] = Species[s].Harvestable.Wt / amountAvailable;\n\n                        // remove DM and N for each mySpecies (digestibility is also evaluated)\n                        Species[s].RemoveBiomass(amountToRemove * fractionToRemove[s], Verbose);\n                    }\n                }\n            }\n        }\n\t}\n    }\n}\n",
          "Parameters": [
            {
              "Key": "Verbose",
              "Value": "False"
            },
            {
              "Key": "PseudoPatches",
              "Value": "False"
            },
            {
              "Key": "ZoneCount",
              "Value": "10"
            },
            {
              "Key": "UrineReturnType",
              "Value": "FromElsewhere"
            },
            {
              "Key": "UrineReturnPattern",
              "Value": "RotatingInOrder"
            },
            {
              "Key": "UrineDepthPenetration",
              "Value": "200"
            }
          ],
          "Name": "PatchZoneManagerForSimpleCow",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Manager, Models",
          "Code": "using System;\nusing Models.Core;\nusing Models.Interfaces;\nusing Models.Soils;\nusing Models.WaterModel;\nusing Models.AgPasture;\nusing System.Linq;\nusing System.Diagnostics;\nusing APSIM.Shared.Utilities;\nusing Models.Soils.Nutrients;\nnamespace Models\n{\n    [Serializable]\n    [System.Xml.Serialization.XmlInclude(typeof(Model))]\n    public class ReportingWithPatchesScript : Model\n    {\n        [Link] private Simulation simulation;\n        [Link] private Clock clock;\n        [Link] private SimpleCowScript simpleCow;\n        [Link] private SimpleGrazing simpleGrazing;\n        [Link(ByName=true)] private ISolute urea;\n        [Link(ByName=true)] private ISolute no3;\n        [Link(ByName=true)] private ISolute nh4;\n\n\n        // --------------- Privates ---------------------------------\n\n        private double iniOrgC;\n        private double iniOrgN;\n       [NonSerialized] private CNPatchVariableType myPatchNO3 = new CNPatchVariableType();\n       [NonSerialized] private CNPatchVariableType myPatchNH4 = new CNPatchVariableType();\n        private bool ReportToday = false;\n\n        // --------------- Enumerated types ---------------------------------\n\n        public enum ReportingFrequencyEnum\n        {\n            Daily,\n            TenDaily,\n            Monthly,\n            Annual,\n            OnGrazing\n        }\n\n        // --------------- Parameters ---------------------------------\n\n        [Description(\"Verbose output?\")]\n        public bool Verbose { get; set; }\n\n        [Description(\"Name of output component for reporting\")]\n        [Display(Type = DisplayType.Model, ModelType=typeof(Report))]\n        public Report OutputModule { get; set; }\n\n        [Description(\"Frequency of reporting\")]\n        public ReportingFrequencyEnum ReportingFreq { get; set; }\n\n        [Description(\"Location for reporting\")]\n        public string Site { get; set; }\n\n        [Description(\"Soil name for reporting\")]\n        public string SoilName { get; set; }\n\n        [Description(\"Low (2800) or high (3500) pasture biomasses for grazing\")]\n        public string Regrowth { get; set; }\n\n        [Description(\"To make analysing the output easier\")]\n        public string Sorter { get; set; }\n\n        [Description(\"For outputing\")]\n        public string LocSoilFert { get; set; }\n\n        // --------------- Outputs ---------------------------------\n\n        public int DaysSinceReport { get; set; }\n        public double NHA { get; set; }\n        public double PGR { get; set; }\n        public double HerbageGrazed { get; set; }\n        public double HerbageGrazedN { get; set; }\n        public double HerbageGrazedMEConc { get; set; }\n        public double UreaReturned { get; set; }\n        public double Fixation { get; set; }\n        public double LeachN { get; set; }\n        public double Denit { get; set; }\n        public double DenitN2O { get; set; }\n        public double OrgC { get; set; }\n        public double OrgN { get; set; }\n        public double dltOrgC { get; set; }\n        public double dltOrgN { get; set; }\n        public double MinN { get; set; }\n        public double UreaN { get; set; }\n        public double NH4N { get; set; }\n        public double NO3N { get; set; }\n        public double UreaAddedInGrazing { get; set; }\n        [Units(\"mm\")] public double Drainage600 { get; set; }\n        public double NetSilageImported { get; set; }\n        public double SumSilageMade { get; set; }\n        public double SumSilageFed { get; set; }\n        public double UrinePatchLoad { get; set; }\n        public int Events { get; set; }\n        public string SiteSoil { get; set; }\n        public double AboveGroundDM { get; set; }\n        public int PatchCount { get; set; }\n        public int z600 { get; set; }\n        public int z300 { get; set; }\n   \n      \n        /// <summary>Invoked when simulation starts.</summary>\n        /// <param name=\"sender\">The sender of the event.</param>\n        /// <param name=\"e\">The event arguments.</param>\n        [EventSubscribe(\"StartOfSimulation\")]\n        private void OnStartOfSimulation(object sender, EventArgs e)\n        {\n            //Debugger.Break();\n              if (Verbose)\n                 Console.WriteLine(\"Initialising the Manager for grazing, urine return and reporting\");\n      \n            DaysSinceReport = 0;\n\n            SiteSoil = Site + SoilName;\n            Events = 1;\n\n            if (Verbose)\n                Console.WriteLine(\"Finished initialising the Manager for grazing, urine return and reporting\");\n        }\n\n\n        // <summary>Invoked by clock to let us do some calculations.</summary>\n        [EventSubscribe(\"DoManagementCalculations\")]\n        private void OnDoManagementCalculations(object sender, EventArgs e)\n        {\n            if (Verbose)\n                 Console.WriteLine(\"In Prepare for the Reporting Manager on \" + clock.Today);\n\n            // if this is the start of the simulation then sort out the depth for the urine placement, can't do this in initialisation because of the module order\n            if (clock.Today == clock.StartDate)\n            {\n                iniOrgC = 0.0; \n                iniOrgN = 0.0;\n                z300 = 0;\n                z600 = 0;\n\n                foreach (Zone paddock in simulation.FindAllChildren<Zone>())\n                {\n                    var soilNitrogen = paddock.FindInScope<Nutrient>();\n                    var soilWater = paddock.FindInScope<WaterBalance>();\n\n                    double tempDepth = 0.0;\n\n                    for (int ii = 0; ii < soilWater.Thickness.Length; ii++)\n                    {\n                       iniOrgC += soilNitrogen.TotalC[ii]; \n                       iniOrgN += soilNitrogen.TotalN[ii];\n                       tempDepth += soilWater.Thickness[ii];\n                       if (tempDepth <= 300)\n                          z300 = ii;\n                       if (tempDepth <= 600)\n                          z600 = ii;\n                    }\n                }\n        }\n\n\n        if (Verbose)\n            Console.WriteLine(\"Finished Prepare for the Reporting Manager on \" + clock.Today);\n        }\n\n\n        // <summary>Invoked by clock to let us do report calculations.</summary>\n        [EventSubscribe(\"DoReportCalculations\")]\n        private void OnDoReportCalculations(object sender, EventArgs e)\n        {\n            if (Verbose)\n                 Console.WriteLine(\"In Post for the Reporting Manager on \" + clock.Today);\n\n            // should reporting be done today?  \n            if (ReportingFreq == ReportingFrequencyEnum.Daily)\n                ReportToday = true;\n            else if ((ReportingFreq == ReportingFrequencyEnum.TenDaily) && ((clock.Today.Day == 10) || (clock.Today.Day == 20) || (DateUtilities.IsEndOfMonth(clock.Today))))\n                ReportToday = true;\n            else if ((ReportingFreq == ReportingFrequencyEnum.Monthly) && (DateUtilities.IsEndOfMonth(clock.Today)))\n                ReportToday = true;\n            else if ((ReportingFreq == ReportingFrequencyEnum.Annual) && (DateUtilities.IsEndOfYear(clock.Today)))\n                ReportToday = true;\n            else if ((ReportingFreq == ReportingFrequencyEnum.OnGrazing) && (simpleGrazing.GrazedToday))\n                ReportToday = true;\n            else\n                ReportToday = false;\n\n            DaysSinceReport += 1;\n\n            // each day gather data for the accumulations\n            foreach (Zone paddock in simulation.FindAllChildren<Zone>())\n            {\n                var sward = paddock.FindAllInScope<PastureSpecies>();\n                var soilWater = paddock.FindInScope<WaterBalance>();\n                var nutrient = paddock.FindInScope<Nutrient>();\n                var denitrificationModel = nutrient.FindInScope<NFlow>();\n\n                AboveGroundDM = sward.Sum(species => species.AboveGroundWt);\n                NHA += sward.Sum(species => species.HerbageGrowthWt);\n                PGR = NHA;  // divide this by the number of days just before reporting\n                Fixation += sward.Sum(species => species.FixedN);\n\n                double[] tempArray = soilWater.FlowNO3;\n                LeachN += tempArray[soilWater.Thickness.Length - 1];  // only take the deepest element\n\n                tempArray = soilWater.Flux;      \n                Drainage600 += tempArray[z600];  //mmm\n\n                for (int ii = 0; ii <= z300; ii++)\n                {\n                    Denit += denitrificationModel.Value[ii];\n                    DenitN2O += nutrient.N2Oatm[ii];\n                }\n            }  \n\n            // Things that come from other Managers or modules at the current level\n            HerbageGrazed += simpleGrazing.GrazedDM;\n            HerbageGrazedN += simpleGrazing.GrazedN;\n            UreaReturned += simpleCow.UrineNReturned;\n            if ((simpleCow.NumPatchesForUrine * simpleCow.NumPatches) > 0)\n                UrinePatchLoad = UreaReturned / (double)simpleCow.NumPatchesForUrine / (double)simpleCow.NumPatches;\n            else\n                UrinePatchLoad = 0.0;\n\n            SumSilageMade += simpleCow.SilageMade;\n            SumSilageFed += simpleCow.SilageFed;\n            NetSilageImported = SumSilageFed - SumSilageMade;\n\n            if (ReportToday)\n            {\n                OrgC = 0.0;\n                OrgN = 0.0;\n                UreaN = 0.0;\n                NH4N = 0.0;\n                NO3N = 0.0;\n                MinN = 0.0;\n\n                foreach (Zone paddock in simulation.FindAllChildren<Zone>())\n                {\n                    var sward = paddock.FindAllInScope<PastureSpecies>();\n                    var soilWater = paddock.FindInScope<WaterBalance>();\n                    var soilNitrogen = paddock.FindInScope<Nutrient>();\n\n                    for (int ii = 0; ii <= (soilWater.Thickness.Length - 1); ii++)\n                    {\n                       OrgC += soilNitrogen.TotalC[ii]; \n                       OrgN += soilNitrogen.TotalN[ii];\n                       UreaN += urea.kgha[ii];\n                       NH4N += nh4.ppm[ii];\n                       NO3N += no3.ppm[ii];\n                       MinN = UreaN + NH4N + NO3N;\n                    }\n                    dltOrgC = OrgC - iniOrgC; \n                    dltOrgN = OrgN - iniOrgN;\n                    iniOrgC = OrgC; // ready for the next calculation of change in pools\n                    iniOrgN = OrgN;\n                }\n\n                PGR = NHA / DaysSinceReport;  \n\n                // do the patch outputs here\n                OutputModule.DoOutput();\n\n                // now zero the reported variables\n                DaysSinceReport = 0;\n                HerbageGrazed = 0.0;\n                HerbageGrazedN = 0.0;\n                DaysSinceReport = 0;\n                NHA = 0;\n                PGR = 0;\n                UreaReturned = 0;\n                Fixation = 0;\n                LeachN = 0;\n                Denit = 0;\n                DenitN2O = 0;\n                OrgC = 0;\n                OrgN = 0;\n                MinN = 0;\n                UreaN = 0;\n                NH4N = 0;\n                NO3N = 0;\n                Drainage600 = 0.0;\n                NetSilageImported = 0.0;\n                SumSilageMade = 0.0;\n                SumSilageFed = 0.0;\n            }\n        }\n    }\n}\n",
          "Parameters": [
            {
              "Key": "Verbose",
              "Value": "False"
            },
            {
              "Key": "OutputModule",
              "Value": "[WholePaddock]"
            },
            {
              "Key": "ReportingFreq",
              "Value": "Daily"
            },
            {
              "Key": "Site",
              "Value": "Ruakura"
            },
            {
              "Key": "SoilName",
              "Value": "HE"
            },
            {
              "Key": "Regrowth",
              "Value": "1low"
            },
            {
              "Key": "Sorter",
              "Value": "S0"
            },
            {
              "Key": "LocSoilFert",
              "Value": "RuaHE100"
            }
          ],
          "Name": "ReportingWithPatches",
          "ResourceName": null,
          "Children": [],
          "Enabled": false,
          "ReadOnly": false
        },
        {
          "$type": "Models.Report, Models",
          "VariableNames": [
            "[Clock].Today",
            "//[SimpleCow].SimpleCowScript.NumPatches"
          ],
          "EventNames": [
            "[Clock].EndOfDay"
          ],
          "GroupByVariableName": null,
          "Name": "WholePaddock",
          "ResourceName": null,
          "Children": [],
          "Enabled": true,
          "ReadOnly": false
        },
        {
          "$type": "Models.Core.Zone, Models",
          "Area": 1.0,
          "Slope": 0.0,
          "AspectAngle": 0.0,
          "Altitude": 50.0,
          "Name": "Paddock",
          "ResourceName": null,
          "Children": [
            {
              "$type": "Models.Manager, Models",
              "Code": "using Newtonsoft.Json;\r\nusing APSIM.Shared.Utilities;\r\nusing System.Xml.Serialization;\r\nusing Models.Soils;\r\nusing Models.PMF;\r\nusing Models.Core;\r\nusing System;\r\nusing Models.Interfaces;\r\n\r\n\r\n\r\n        \r\nnamespace Models\r\n{\r\n    [Serializable] \r\n    [System.Xml.Serialization.XmlInclude(typeof(Model))]\r\n    public class Script : Model\r\n    {\r\n        [Link] private ISummary summary;\r\n        [Link] private Irrigation Irrigation;\r\n        [Link] private Clock Clock;\r\n        [Link] private Soil Soil;\r\n        [Link(IsOptional = true)] private IPlant existingCrop;\r\n        private DateTime StartDate;\r\n        private DateTime EndDate;\r\n        private double TopDUL;\r\n        private double TopLL;\r\n        private int nLayers;\r\n        [Link]\r\n        private IPhysical soilPhysical;\r\n        [Link]\r\n        private ISoilWater waterBalance;\r\n        //Communication to other modules\r\n       \r\n        //User inputs from properties tab\r\n        [Description(\"Turn irrigation on?\")]\r\n        public bool allowIrrigation { get; set; } = true;\r\n\n        [Description(\"Allow reporting to the summary file?\")]\r\n        public bool allowReporting { get; set; }\r\n\n\n        [Description(\"Start of irrigation season (dd-MMM)\")]\r\n        public string seasonStart { get; set; }\r\n\n\n        [Description(\"End of irrigation season (dd-MMM)\")]\r\n        public string seasonEnd { get; set; }\r\n\n\n        [Description(\"Season allocation (mm)\")]\r\n        public double seasonsAllocation { get; set; }\r\n\n\n        [Description(\"Deficit to trigger irrigation (% PAWC)\")]\r\n        public double triggerDeficit { get; set; }\r\n\n\n        [Description(\"Deficit to stop irrigaton (% PAWC)\")]\r\n        public double targetDeficit { get; set; }\r\n\n\n        [Description(\"Minimum days for irrigation to return\")]\r\n        public double returndays { get; set; }\r\n\n        [Description(\"Maximum irrigation application (mm/day)\")]\r\n        public double maximumAmount { get; set; }\r\n\n        [Description(\"Depth to calculate PAWC (mm)\")]\r\n        public double depthPAWC { get; set; }\r\n\r\n        //Class members\r\n        [JsonIgnore] public double TopSWdeficit { get; set; }\r\n        [JsonIgnore] public double TopSWC { get; set; }\r\n        [JsonIgnore] public double DaysSinceIrrigation { get; set; }\r\n        [JsonIgnore] public double AmountToApply { get; set; }\r\n        [JsonIgnore] public double SeasonAppliedAmount { get; set; }\r\n        \r\n        private bool IrrigationIsAllowed { get; set; }\r\n        private bool SeasonIsOpen { get; set; }\r\n        private bool CropIsActive { get; set; }\r\n        private bool IrrigatorIsAvailable { get; set; }\r\n        private bool SoilIsDry { get; set; }\r\n\r\n    \r\n        //Calculate static soil variables\r\n        [EventSubscribe(\"StartOfSimulation\")]\r\n        private void OnStartOfSimulation(object sender, EventArgs e)\r\n        {   \r\n            //Set the season dates\r\n            StartDate = DateTime.Parse(seasonStart + \"-\" + Clock.Today.Year.ToString());\r\n            EndDate = DateTime.Parse(seasonEnd + \"-\" + Clock.Today.Year.ToString());\r\n            \n           \r\n            //Can we irrigate at all?\r\n            IrrigationIsAllowed = false; \r\n            if (allowIrrigation)\r\n                IrrigationIsAllowed = true; \r\n\r\n            //Calculate soil water variables\r\n            double depthFromSurface = 0.0;\r\n            double fracLayer = 0.0;\r\n            nLayers = soilPhysical.Thickness.Length;\r\n            for (int layer = 0; layer < nLayers; layer++)\r\n            {\r\n                fracLayer = Math.Min(1.0, (depthPAWC - depthFromSurface) / soilPhysical.Thickness[layer]);\r\n                TopLL += soilPhysical.LL15mm[layer] * fracLayer;\r\n                TopDUL += soilPhysical.DULmm[layer] * fracLayer;\r\n                depthFromSurface += soilPhysical.Thickness[layer];\r\n                if (depthFromSurface >= depthPAWC)\r\n                    layer = nLayers;\r\n            }\r\n        }\r\n             \r\n        //Determine daily requirement for irrigation\r\n        [EventSubscribe(\"StartOfDay\")]\r\n        private void OnStartOfDay(object sender, EventArgs e)\r\n        {\r\n            //Can we irrigate today?          \r\n            SeasonIsOpen = isBetween(Clock.Today, StartDate, EndDate);\r\n            if (!SeasonIsOpen)\r\n                SeasonAppliedAmount = 0;\r\n\r\n            //Is there a crop in the ground that needs irrigation?\r\n            CropIsActive = false;\r\n            if ((existingCrop != null) && (existingCrop.IsAlive))\r\n                CropIsActive = true;\r\n            //if ((existingCrop.Phenology.Stage >= 3.0) && (existingCrop.Phenology.Stage < 6.0))\r\n          \r\n            //Is the irrigator available?\r\n            IrrigatorIsAvailable = false;\r\n            DaysSinceIrrigation += 1;\r\n            if (DaysSinceIrrigation >= returndays)\r\n                IrrigatorIsAvailable = true;\r\n          \r\n            //Is the soil dry enough to require irrigation?\r\n            SoilIsDry = false;\r\n            double depthFromSurface = 0.0;\r\n            double fracLayer = 0.0;\r\n            TopSWC = 0.0;\r\n            for (int layer = 0; layer < nLayers; layer++)\r\n            //for (int layer = 0; depthFromSurface < depthPAWC + soilPhysical.Thickness[layer]; layer++)\r\n            {\r\n                fracLayer = Math.Min(1.0, (depthPAWC - depthFromSurface) / soilPhysical.Thickness[layer]);\r\n                TopSWC += waterBalance.SWmm[layer] * fracLayer;\r\n                depthFromSurface += soilPhysical.Thickness[layer];\r\n                if (depthFromSurface >= depthPAWC)\r\n                    layer = nLayers;\r\n            }\r\n            \r\n            TopSWdeficit = TopSWC - TopDUL;\r\n            if (Math.Max(0.0, -TopSWdeficit) >= (TopDUL - TopLL) * (100 - triggerDeficit) / 100)\r\n                SoilIsDry = true;\r\n                \r\n            //Are all the conditions ratifying irrigation\r\n            if (IrrigationIsAllowed && SeasonIsOpen && CropIsActive && IrrigatorIsAvailable && SoilIsDry)\r\n            {\r\n                //Lets bloody well irrigate then!!!!\r\n                AmountToApply = TopDUL * targetDeficit / 100 - TopSWC;\r\n                AmountToApply = Math.Max(0.0, Math.Min(AmountToApply, seasonsAllocation - SeasonAppliedAmount));\r\n                AmountToApply = Math.Min(AmountToApply,maximumAmount);\r\n                \n                Irrigation.Apply(AmountToApply, doOutput:  allowReporting);\r\n                \n                DaysSinceIrrigation = 0;\r\n                SeasonAppliedAmount += AmountToApply;\r\n            }\r\n        }\r\n        \r\n        ///Checks whether theDate is between iniDate and endDate (non-year specific)\r\n        private bool isBetween(DateTime theDay, DateTime iniDate, DateTime endDate)\r\n        {\r\n            bool result = false;\r\n            if (iniDate.DayOfYear < endDate.DayOfYear)\r\n            {\r\n                // period is within one year, ex: summer in the northern hemisphere\r\n                if ((theDay.DayOfYear >= iniDate.DayOfYear) && (theDay.DayOfYear <= endDate.DayOfYear))\r\n                    result = true;\r\n            }\r\n            else\r\n            {\r\n                // period goes over the end of the year, ex: summer in the southern hemisphere\r\n                if ((theDay.DayOfYear >= iniDate.DayOfYear) || (theDay.DayOfYear <= endDate.DayOfYear))\r\n                    result = true;\r\n            }\r\n            \r\n            return result;\r\n        }\r\n    }\r\n}\r\n",
              "Parameters": [
                {
                  "Key": "allowIrrigation",
                  "Value": "True"
                },
                {
                  "Key": "allowReporting",
                  "Value": "False"
                },
                {
                  "Key": "seasonStart",
                  "Value": "1-sep"
                },
                {
                  "Key": "seasonEnd",
                  "Value": "30-mar"
                },
                {
                  "Key": "seasonsAllocation",
                  "Value": "10000"
                },
                {
                  "Key": "triggerDeficit",
                  "Value": "80"
                },
                {
                  "Key": "targetDeficit",
                  "Value": "95"
                },
                {
                  "Key": "returndays",
                  "Value": "3"
                },
                {
                  "Key": "maximumAmount",
                  "Value": "30"
                },
                {
                  "Key": "depthPAWC",
                  "Value": "300"
                }
              ],
              "Name": "AutomaticIrrigation",
              "ResourceName": null,
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.AgPasture.SimpleGrazing, Models",
              "GrazingRotationType": 1,
              "SimpleGrazingFrequencyString": "0",
              "SimpleMinGrazable": 0.0,
              "SimpleGrazingResidual": 1000.0,
              "PreGrazeDMArray": [
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0,
                2800.0
              ],
              "PostGrazeDMArray": [
                1500.0,
                1500.0,
                1500.0,
                1500.0,
                1250.0,
                1250.0,
                1250.0,
                1250.0,
                1500.0,
                1500.0,
                1500.0,
                1500.0
              ],
              "FlexibleExpressionForTimingOfGrazing": null,
              "FlexibleGrazePostDM": 0.0,
              "MaximumRotationLengthArray": [
                50.0,
                50.0,
                50.0,
                50.0,
                60.0,
                60.0,
                90.0,
                70.0,
                50.0,
                50.0,
                50.0,
                50.0
              ],
              "MinimumRotationLengthArray": [
                1.0,
                1.0,
                1.0,
                1.0,
                3.0,
                3.0,
                3.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0
              ],
              "NoGrazingStartString": null,
              "NoGrazingEndString": null,
              "FractionDefoliatedNToSoil": [
                0.75
              ],
              "FractionExcretedNToDung": [
                0.4
              ],
              "CNRatioDung": 0.0,
              "DepthUrineIsAdded": 250.0,
              "FractionPopulationDecline": 0.0,
              "TramplingOn": false,
              "MaximumPropLitterMovedToSoil": 0.1,
              "PastureConsumedAtMaximumRateOfLitterRemoval": 1200.0,
              "SpeciesCutProportions": null,
              "Name": "SimpleGrazing",
              "ResourceName": null,
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.Surface.SurfaceOrganicMatter, Models",
              "SurfOM": [],
              "Canopies": [],
              "InitialResidueName": "grass",
              "InitialResidueType": "grass",
              "InitialResidueMass": 500.0,
              "InitialStandingFraction": 0.0,
              "InitialCPR": 0.0,
              "InitialCNR": 10.0,
              "Name": "SurfaceOrganicMatter",
              "ResourceName": "SurfaceOrganicMatter",
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.Fertiliser, Models",
              "Name": "Fertiliser",
              "ResourceName": "Fertiliser",
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.Irrigation, Models",
              "Name": "Irrigation",
              "ResourceName": null,
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.Soils.Soil, Models",
              "RecordNumber": 0,
              "ASCOrder": null,
              "ASCSubOrder": null,
              "SoilType": "MergeAge40",
              "LocalName": null,
              "Site": "-",
              "NearestTown": "-",
              "Region": "Plains",
              "State": "Canterbury",
              "Country": "New Zealand",
              "NaturalVegetation": null,
              "ApsoilNumber": null,
              "Latitude": 0.0,
              "Longitude": 0.0,
              "LocationAccuracy": null,
              "YearOfSampling": null,
              "DataSource": "Generic profile descriptions provided by Trevor Webb and data for functional horizions based on SWAMP project results",
              "Comments": "Bulk density values were measured on the fine earth fraction so values entered into apsim soil are adjusted down to account for stone content (assuming stones are inert from all soil process so their mass and volume is removed from model paramaters).  SAT, DUL, LL15 and Air dry have been adjusted down to account for stone content.  OC has not been adjusted so the model will get the correct carbon and N amounts using the adjusted BD.",
              "Name": "HE_140mm",
              "ResourceName": null,
              "Children": [
                {
                  "$type": "Models.Soils.Physical, Models",
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "ParticleSizeClay": [
                    20.0,
                    24.0,
                    39.0,
                    44.0,
                    44.0,
                    19.0,
                    19.0
                  ],
                  "ParticleSizeSand": [
                    14.5,
                    18.0,
                    13.0,
                    1.0,
                    1.0,
                    15.0,
                    15.0
                  ],
                  "ParticleSizeSilt": [
                    65.5,
                    58.0,
                    48.0,
                    55.0,
                    55.0,
                    66.0,
                    66.0
                  ],
                  "Rocks": null,
                  "Texture": null,
                  "BD": [
                    1.3105,
                    1.524,
                    1.42,
                    1.424,
                    1.424,
                    1.601,
                    1.601
                  ],
                  "AirDry": [
                    0.07675,
                    0.201,
                    0.2985,
                    0.308,
                    0.308,
                    0.162,
                    0.162
                  ],
                  "LL15": [
                    0.1535,
                    0.201,
                    0.2985,
                    0.308,
                    0.308,
                    0.162,
                    0.162
                  ],
                  "DUL": [
                    0.3735,
                    0.332,
                    0.426,
                    0.446,
                    0.446,
                    0.325,
                    0.325
                  ],
                  "SAT": [
                    0.456165,
                    0.39432,
                    0.441525,
                    0.4557,
                    0.456,
                    0.376,
                    0.376
                  ],
                  "KS": null,
                  "BDMetadata": null,
                  "AirDryMetadata": null,
                  "LL15Metadata": null,
                  "DULMetadata": null,
                  "SATMetadata": null,
                  "KSMetadata": null,
                  "RocksMetadata": null,
                  "TextureMetadata": null,
                  "ParticleSizeSandMetadata": null,
                  "ParticleSizeSiltMetadata": null,
                  "ParticleSizeClayMetadata": null,
                  "Name": "Physical",
                  "ResourceName": null,
                  "Children": [
                    {
                      "$type": "Models.Soils.SoilCrop, Models",
                      "LL": [
                        0.154,
                        0.201,
                        0.299,
                        0.308,
                        0.308,
                        0.162,
                        0.162
                      ],
                      "KL": [
                        0.1,
                        0.1,
                        0.1,
                        0.05,
                        0.05,
                        0.05,
                        0.05
                      ],
                      "XF": [
                        1.0,
                        0.8,
                        0.8,
                        0.3,
                        0.0,
                        0.0,
                        0.0
                      ],
                      "LLMetadata": null,
                      "KLMetadata": null,
                      "XFMetadata": null,
                      "Name": "AGPRyegrassSoil",
                      "ResourceName": null,
                      "Children": [],
                      "Enabled": true,
                      "ReadOnly": false
                    },
                    {
                      "$type": "Models.Soils.SoilCrop, Models",
                      "LL": [
                        0.154,
                        0.201,
                        0.299,
                        0.308,
                        0.308,
                        0.162,
                        0.162
                      ],
                      "KL": [
                        0.1,
                        0.1,
                        0.1,
                        0.05,
                        0.05,
                        0.05,
                        0.05
                      ],
                      "XF": [
                        1.0,
                        0.8,
                        0.8,
                        0.3,
                        0.0,
                        0.0,
                        0.0
                      ],
                      "LLMetadata": null,
                      "KLMetadata": null,
                      "XFMetadata": null,
                      "Name": "AGPWhiteCloverSoil",
                      "ResourceName": null,
                      "Children": [],
                      "Enabled": true,
                      "ReadOnly": false
                    }
                  ],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.Organic, Models",
                  "FOMCNRatio": 40.0,
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "Carbon": [
                    4.502,
                    1.91,
                    0.772,
                    0.422,
                    0.422,
                    0.402,
                    0.4
                  ],
                  "CarbonUnits": 0,
                  "SoilCNRatio": [
                    11.0,
                    11.0,
                    11.0,
                    11.0,
                    11.0,
                    11.0,
                    11.0
                  ],
                  "FBiom": [
                    0.048,
                    0.027,
                    0.019,
                    0.015,
                    0.015,
                    0.015,
                    0.015
                  ],
                  "FInert": [
                    0.382,
                    0.634,
                    0.784,
                    0.924,
                    0.924,
                    0.971,
                    0.985
                  ],
                  "FOM": [
                    347.67,
                    257.56,
                    172.648,
                    85.734,
                    63.514,
                    47.052,
                    25.823
                  ],
                  "CarbonMetadata": null,
                  "FOMMetadata": null,
                  "Name": "Organic",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.Chemical, Models",
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "PH": [
                    6.0,
                    6.0,
                    6.0,
                    6.0,
                    6.0,
                    6.0,
                    6.0
                  ],
                  "PHUnits": 0,
                  "EC": null,
                  "ESP": null,
                  "ECMetadata": null,
                  "CLMetadata": null,
                  "ESPMetadata": null,
                  "PHMetadata": null,
                  "Name": "Chemical",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.Water, Models",
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "InitialValues": [
                    0.373,
                    0.332,
                    0.426,
                    0.446,
                    0.446,
                    0.325,
                    0.325
                  ],
                  "RelativeTo": "LL15",
                  "FilledFromTop": true,
                  "Name": "Water",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.CERESSoilTemperature, Models",
                  "Name": "Temperature",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.WaterModel.WaterBalance, Models",
                  "SummerDate": "1-Nov",
                  "SummerU": 6.0,
                  "SummerCona": 3.5,
                  "WinterDate": "1-Apr",
                  "WinterU": 6.0,
                  "WinterCona": 2.5,
                  "DiffusConst": 0.0,
                  "DiffusSlope": 0.0,
                  "Salb": 0.0,
                  "CN2Bare": 0.0,
                  "CNRed": 20.0,
                  "CNCov": 0.8,
                  "DischargeWidth": 5.0,
                  "CatchmentArea": 10.0,
                  "PSIDul": -100.0,
                  "Thickness": [],
                  "SWCON": null,
                  "KLAT": null,
                  "Name": "WaterBalance",
                  "ResourceName": "WaterBalance",
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.Nutrients.Nutrient, Models",
                  "Name": "Nutrient",
                  "ResourceName": "Nutrient",
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.NutrientPatching.SolutePatch, Models",
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "InitialValues": null,
                  "InitialValuesUnits": 0,
                  "WaterTableConcentration": 0.0,
                  "D0": 0.0,
                  "Exco": null,
                  "FIP": null,
                  "DepthConstant": 0.0,
                  "MaxDepthSoluteAccessible": 0.0,
                  "RunoffEffectivenessAtMovingSolute": 0.0,
                  "MaxEffectiveRunoff": 0.0,
                  "Name": "NO3",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.NutrientPatching.SolutePatch, Models",
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "InitialValues": null,
                  "InitialValuesUnits": 0,
                  "WaterTableConcentration": 0.0,
                  "D0": 0.0,
                  "Exco": null,
                  "FIP": null,
                  "DepthConstant": 0.0,
                  "MaxDepthSoluteAccessible": 0.0,
                  "RunoffEffectivenessAtMovingSolute": 0.0,
                  "MaxEffectiveRunoff": 0.0,
                  "Name": "NH4",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.NutrientPatching.SolutePatch, Models",
                  "Thickness": [
                    200.0,
                    150.0,
                    200.0,
                    350.0,
                    150.0,
                    150.0,
                    300.0
                  ],
                  "InitialValues": null,
                  "InitialValuesUnits": 1,
                  "WaterTableConcentration": 0.0,
                  "D0": 0.0,
                  "Exco": null,
                  "FIP": null,
                  "DepthConstant": 0.0,
                  "MaxDepthSoluteAccessible": 0.0,
                  "RunoffEffectivenessAtMovingSolute": 0.0,
                  "MaxEffectiveRunoff": 0.0,
                  "Name": "Urea",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                },
                {
                  "$type": "Models.Soils.NutrientPatching.NutrientPatchManager, Models",
                  "MaximumNitrogenAvailableToPlants": 0.0,
                  "NPartitionApproach": 0,
                  "AutoAmalgamationApproach": 0,
                  "basePatchApproach": 0,
                  "AllowPatchAmalgamationByAge": false,
                  "PatchAgeForForcedMerge": 0.0,
                  "LayerForNPartition": -99.0,
                  "Name": "NutrientPatchManager",
                  "ResourceName": null,
                  "Children": [],
                  "Enabled": true,
                  "ReadOnly": false
                }
              ],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.AgPasture.PastureSpecies, Models",
              "doyGermination": 275,
              "daysEmergenceToAnthesis": 120,
              "daysAnthesisToMaturity": 85,
              "degreesDayForAnthesis": 1100.0,
              "degreesDayForMaturity": 900.0,
              "daysAnnualsFactor": 45,
              "FVPDFunction": {
                "$type": "Models.Functions.LinearInterpolationFunction, Models",
                "Name": "LinearInterpolationFunction",
                "ResourceName": null,
                "Children": [],
                "Enabled": true,
                "ReadOnly": false
              },
              "LightProfile": null,
              "InitialShootDM": 1500.0,
              "InitialRootDM": 450.0,
              "InitialRootDepth": 750.0,
              "initialDMFractionsGrasses": [
                0.15,
                0.25,
                0.25,
                0.05,
                0.05,
                0.1,
                0.1,
                0.05,
                0.0,
                0.0,
                0.0
              ],
              "initialDMFractionsLegumes": [
                0.16,
                0.23,
                0.22,
                0.05,
                0.03,
                0.05,
                0.05,
                0.01,
                0.04,
                0.08,
                0.08
              ],
              "initialDMFractionsForbs": [
                0.2,
                0.2,
                0.15,
                0.05,
                0.1,
                0.15,
                0.1,
                0.05,
                0.0,
                0.0,
                0.0
              ],
              "PhotosyntheticEfficiency": 0.01,
              "PhotosynthesisCurveFactor": 0.8,
              "FractionPAR": 0.5,
              "ReferenceCO2": 380.0,
              "CO2EffectScaleFactor": 700.0,
              "CO2EffectOffsetFactor": 600.0,
              "CO2EffectMinimum": 0.7,
              "CO2EffectExponent": 2.0,
              "ReproSeasonDurationCoeff": 2.0,
              "ReproSeasonShouldersLengthFactor": 1.0,
              "ReproSeasonOnsetDurationFactor": 0.6,
              "RelativeTurnoverEmerging": 2.0,
              "DetachmentDroughtCoefficient": 3.0,
              "DetachmentDroughtEffectMin": 0.1,
              "TurnoverStockFactor": 0.01,
              "TurnoverDefoliationEffectMin": 0.025,
              "MinimumGreenLeafProp": 0.8,
              "MinimumGreenRootProp": 0.5,
              "Name": "AGPRyegrass",
              "ResourceName": "AGPRyegrass",
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.AgPasture.PastureSpecies, Models",
              "doyGermination": 275,
              "daysEmergenceToAnthesis": 120,
              "daysAnthesisToMaturity": 85,
              "degreesDayForAnthesis": 1100.0,
              "degreesDayForMaturity": 900.0,
              "daysAnnualsFactor": 45,
              "FVPDFunction": {
                "$type": "Models.Functions.LinearInterpolationFunction, Models",
                "Name": "LinearInterpolationFunction",
                "ResourceName": null,
                "Children": [],
                "Enabled": true,
                "ReadOnly": false
              },
              "LightProfile": null,
              "InitialShootDM": 500.0,
              "InitialRootDM": 150.0,
              "InitialRootDepth": 350.0,
              "initialDMFractionsGrasses": [
                0.15,
                0.25,
                0.25,
                0.05,
                0.05,
                0.1,
                0.1,
                0.05,
                0.0,
                0.0,
                0.0
              ],
              "initialDMFractionsLegumes": [
                0.16,
                0.23,
                0.22,
                0.05,
                0.03,
                0.05,
                0.05,
                0.01,
                0.04,
                0.08,
                0.08
              ],
              "initialDMFractionsForbs": [
                0.2,
                0.2,
                0.15,
                0.05,
                0.1,
                0.15,
                0.1,
                0.05,
                0.0,
                0.0,
                0.0
              ],
              "PhotosyntheticEfficiency": 0.01,
              "PhotosynthesisCurveFactor": 0.8,
              "FractionPAR": 0.5,
              "ReferenceCO2": 380.0,
              "CO2EffectScaleFactor": 700.0,
              "CO2EffectOffsetFactor": 600.0,
              "CO2EffectMinimum": 0.7,
              "CO2EffectExponent": 2.0,
              "ReproSeasonDurationCoeff": 2.0,
              "ReproSeasonShouldersLengthFactor": 1.0,
              "ReproSeasonOnsetDurationFactor": 0.6,
              "RelativeTurnoverEmerging": 2.0,
              "DetachmentDroughtCoefficient": 3.0,
              "DetachmentDroughtEffectMin": 0.1,
              "TurnoverStockFactor": 0.01,
              "TurnoverDefoliationEffectMin": 0.025,
              "MinimumGreenLeafProp": 0.8,
              "MinimumGreenRootProp": 0.5,
              "Name": "AGPWhiteClover",
              "ResourceName": "AGPWhiteClover",
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            },
            {
              "$type": "Models.Report, Models",
              "VariableNames": [
                "[Clock].Today",
                "[Decomposition].MineralisedN",
                "[Nutrient].MineralisedN",
                "[NO3].kgha",
                "[NH4].kgha",
                "[Urea].kgha"
              ],
              "EventNames": [
                "[Clock].EndOfDay"
              ],
              "GroupByVariableName": null,
              "Name": "Report",
              "ResourceName": null,
              "Children": [],
              "Enabled": true,
              "ReadOnly": false
            }
          ],
          "Enabled": true,
          "ReadOnly": false
        }
      ],
      "Enabled": true,
      "ReadOnly": false
    },
    {
      "$type": "Models.Report, Models",
      "VariableNames": [
        "[Clock].Today",
        "[SimpleCow].SimpleCowScript.NumPatches",
        "[ReportingWithPatches].ReportingWithPatchesScript.LocSoilFert as LocSoil",
        "[SimpleCow].SimpleCowScript.UrinationsPerHead",
        "[SimpleCow].SimpleCowScript.ForageType",
        "[SimpleCow].SimpleCowScript.patchMargin",
        "[SimpleCow].SimpleCowScript.StockingRate",
        "[SimpleCow].SimpleCowScript.GeneralFertAmt",
        "[SimpleGrazing].GrazingInterval",
        "[SimpleGrazing].PreGrazeDM as PreGrazeDM",
        "[SimpleGrazing].PostGrazeDM",
        "[SimpleCow].SimpleCowScript.HerdMEDemand",
        "[SimpleCow].SimpleCowScript.LoadAdjustmentPropOverall as LoadAdjustment",
        "[SimpleCow].SimpleCowScript.AverageUrineDepth",
        "[ReportingWithPatches].ReportingWithPatchesScript.Events",
        "[ReportingWithPatches].ReportingWithPatchesScript.UreaReturned as UrineNReturned",
        "[SimpleCow].SimpleCowScript.NumPatchesForUrine as GridsUsed",
        "[ReportingWithPatches].ReportingWithPatchesScript.UrinePatchLoad",
        "[SimpleGrazing].GrazedDM",
        "[SimpleGrazing].GrazedN",
        "[ReportingWithPatches].ReportingWithPatchesScript.LeachN",
        "[ReportingWithPatches].ReportingWithPatchesScript.Denit",
        "[ReportingWithPatches].ReportingWithPatchesScript.DenitN2O",
        "[ReportingWithPatches].ReportingWithPatchesScript.Fixation",
        "[ReportingWithPatches].ReportingWithPatchesScript.MinN",
        "[ReportingWithPatches].ReportingWithPatchesScript.dltOrgN",
        "[ReportingWithPatches].ReportingWithPatchesScript.Drainage600",
        "[SimpleCow].SimpleCowScript.CowDMIntake",
        "[ReportingWithPatches].ReportingWithPatchesScript.NHA",
        "[ReportingWithPatches].ReportingWithPatchesScript.PGR",
        "[ReportingWithPatches].ReportingWithPatchesScript.NetSilageImported",
        "[ReportingWithPatches].ReportingWithPatchesScript.SumSilageMade as SilageMade",
        "[ReportingWithPatches].ReportingWithPatchesScript.SumSilageFed as SilageFed",
        "[SimpleCow].SimpleCowScript.StockingDensity",
        "[SimpleCow].SimpleCowScript.CowState",
        "[SimpleCow].SimpleCowScript.ListOfPatches"
      ],
      "EventNames": [
        "[Clock].EndOfDay"
      ],
      "GroupByVariableName": null,
      "Name": "WholePaddockOriginal",
      "ResourceName": null,
      "Children": [],
      "Enabled": false,
      "ReadOnly": false
    }
  ],
  "Enabled": true,
  "ReadOnly": false
}